// Package userprefs defines interfaces for storage, caching, and logging used in user preferences management.
package userprefs

import (
	"context"
	"time"
)

// Storage defines the contract for persistent storage and retrieval of user preferences.
// Implementations are responsible for interacting with the underlying data store (e.g., SQL database, NoSQL database, file system).
// All methods that accept a context.Context should honor its cancellation and timeout signals.
// Implementations must be thread-safe, allowing for concurrent access from multiple goroutines.
type Storage interface {
	// Get retrieves a specific Preference for a given userID and key.
	// It must return a non-nil Preference and a nil error on success.
	// If the preference is not found, it must return nil for the Preference and userprefs.ErrNotFound error.
	// Other errors may be returned for issues like database connectivity problems.
	Get(ctx context.Context, userID, key string) (*Preference, error)

	// Set creates a new preference or updates an existing one (upsert operation).
	// The provided Preference struct contains all necessary information (UserID, Key, Value, etc.).
	// Implementations should ensure that the UpdatedAt field of the stored preference is set to the current time.
	// It returns a nil error on success, or an error if the operation fails (e.g., due to database issues or serialization problems).
	Set(ctx context.Context, pref *Preference) error

	// Delete removes a specific preference for a given userID and key.
	// This method must be idempotent: it should return a nil error even if the
	// preference does not exist or has already been deleted.
	// An error should only be returned for underlying storage issues.
	Delete(ctx context.Context, userID, key string) error

	// GetAll retrieves all preferences associated with a specific userID.
	// It returns a map where keys are preference keys and values are pointers to Preference structs.
	// If the user has no preferences, it must return a non-nil, empty map and a nil error.
	// An error is returned for underlying storage issues.
	GetAll(ctx context.Context, userID string) (map[string]*Preference, error)

	// GetByCategory retrieves all preferences for a specific userID that belong to the specified category.
	// It returns a map where keys are preference keys and values are pointers to Preference structs.
	// If the user has no preferences in the given category, or the category does not exist,
	// it must return a non-nil, empty map and a nil error.
	// An error is returned for underlying storage issues.
	GetByCategory(ctx context.Context, userID, category string) (map[string]*Preference, error)

	// Close releases any resources held by the storage backend, such as database connections.
	// It should be called when the Storage instance is no longer needed to prevent resource leaks.
	// Implementations should ensure this method is safe to call multiple times, though typically called once.
	Close() error
}

// Cache defines the contract for a caching layer.
// It is used by the Manager to temporarily store marshalled user preferences
// for faster retrieval and to reduce load on the primary Storage backend.
// All methods that accept a context.Context should honor its cancellation and timeout signals.
// Implementations must be thread-safe for concurrent access.
// The cache key is typically a composite string generated by the Manager (e.g., "user_id:preference_key").
type Cache interface {
	// Get retrieves an item from the cache by its key.
	// The key is typically a string identifying the cached Preference (e.g., a composite of userID and preference key).
	// On a cache hit, it returns the cached item as a byte slice (`[]byte`) and a nil error.
	// The caller (e.g., the Manager) is responsible for unmarshalling this byte slice into the appropriate data structure.
	// On a cache miss (item not found or expired), it must return nil for the byte slice and an error
	// that can be checked using `errors.Is(err, userprefs.ErrNotFound)`.
	// Other errors may indicate issues with the cache backend itself.
	Get(ctx context.Context, key string) ([]byte, error)

	// Set adds an item to the cache with a specific key and time-to-live (TTL).
	// The 'value' must be a byte slice (`[]byte`), typically the marshalled form of a Preference.
	// The caller (e.g., the Manager) is responsible for marshalling the data into a byte slice before calling Set.
	// The 'ttl' (time-to-live) specifies how long the item should remain in the cache.
	// A TTL of 0 might be interpreted by some implementations as "cache forever" or "use default TTL",
	// so specific behavior should be documented by the implementation.
	// Returns a nil error on success, or an error if the operation fails.
	Set(ctx context.Context, key string, value []byte, ttl time.Duration) error

	// Delete removes an item from the cache by its key.
	// This method must be idempotent: it should return a nil error even if the
	// key does not exist in the cache or has already been deleted.
	// An error should only be returned for underlying cache system issues.
	Delete(ctx context.Context, key string) error

	// Close releases any resources held by the cache backend, such as network connections or background goroutines.
	// It should be called when the Cache instance is no longer needed, especially for caches that manage persistent connections.
	// Implementations should ensure this method is safe to call multiple times.
	Close() error
}

// EncryptionManager defines the contract for encrypting and decrypting preference values.
// It provides AES-256 encryption capabilities for sensitive user preferences marked as encrypted.
// Implementations must be thread-safe for concurrent access from multiple goroutines.
type EncryptionManager interface {
	// Encrypt encrypts plaintext and returns the encrypted value as a string.
	// The implementation should use secure encryption (AES-256-GCM) and handle
	// base64 encoding of the result for storage compatibility.
	// Returns an error if encryption fails.
	Encrypt(plaintext string) (string, error)

	// Decrypt decrypts an encrypted value and returns the original plaintext.
	// The encrypted value is expected to be in the format produced by Encrypt.
	// Returns an error if decryption fails or the encrypted value is invalid.
	Decrypt(encrypted string) (string, error)
}
